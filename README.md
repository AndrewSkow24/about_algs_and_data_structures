# Алгоритмы и структуры данных

## Темы

1. [Основы алгоритмов](#основы-алгоритмов)
2. [Оценка сложности (big O, временная и пространственная)](#оценка-алгоритма)
3. [Работа с данными (стек, куча heap)](#данные)
4. [Как устроены массивы и как хранятся в памяти](#массивы)
5. [Поиск (линейный и бинарный)](#бинарный-поиск)
6. [Рекурсия](#рекурсия)
7. Разделяй и властвуй
8. [Сортировка (пузырьком, выбором, быстрая сортировка 2 способа)](#сортировка)
9. Связные списки
10. Стек
11. Очередь и дек
12. Графы. Поиск в ширину и глубину. Алгоритмы Дейкстры. Матрица смежности
13. Многомерные массивы
14. Деревья. Бинарное дерево поиска. Дерево N-размерности
15. Хэш-таблицы
16. Комбинаторика. Перестановки, сочетания и размещения
17. Жадные алгоритмы

## Основы алгоритмов

Повторяющиеся действия называются итерациями и выполняются в цикле.
Алгоритм в коде - это последовательность действий.
Алгоритм может быть эффективный или неэффективный.

## Оценка алгоритма

Эффективность алгоритма оценивается

1. По времени (количество операций)
2. По затраченным ресурсам (память)

Под временем не подразумеваются секунды, а подразумевается временная
сложность O(n).

Эффективность алгоритма по памяти называется пространственная
сложность O(n).

В обоих случаях используется нотация big O: O(n)

Нотация O(n) не сообщает нам точное количество операций или
точный объём данных, а показывает как растёт функция с ростом входных данных или ростом
количества операций.

### Примеры алгоритмической сложности

1. `O(1)` - константная
2. `O(log n)` - логарифмическая
3. `O(n)` - линейная
4. `O(n**2)` - квадратичная
5. `O(n**3)` - кубическая
6. `O(n!)` - факториальная

Логарифмическая сложность характерна для алогритмов, где
объём исходных данных делится на 2.

Пример линейной сложности - обработка массива в цикле.

Квадратичная сложность: цикл в цикле

Кубическая сложность: цикл в цикле в цикле

Логарифмическая сложность: данные делятся на 2 части, и дальнейшая работа только с оставшимися
частями.

```
[1,2,3,4,5,6,7,8,9,10]

Делится на

[1,2,3,4,5]

и

[6,7,8,9,10]
```

Квадратичная сложность - 2 вложенных цикла

```js
const data = [1, 2, 3, 4, 5];

for (let i = 0; i < data.length; i++) {
  for (let j = 0; j < data.length; j++) {
    //
  }
}
```

Если два исходных массива с разным количеством элементов сложность будет `O(k*m)`

```js
const data = [1, 2, 3, 4, 5];
const data2 = [1, 2, 3];

for (let i = 0; i < length; i++) {
  for (let j = 0; j < length; j++) {
    //
  }
}
```

Функция с факториальной временной сложностью `O(n!)` выполняет работа, которая увеличивается факториально с ростом входных данных. Пример: генерация всех перестановок массива.

Константы при оценки сложности алгоритма не учитываются, они отбрасываются, потому что на рост функции они никак не влияют.

Сложность не призвана отобразить точное количество операций.

Она показывает как растёт функция с ростом входных данных.

### Сравнение O(n) и количества операций

|           |  1  |  100   |   1 000   |    1 000 0000     |
| :-------: | :-: | :----: | :-------: | :---------------: |
| O(log n)  |  1  |   7    |    10     |        20         |
|   O(n)    |  1  |  100   |   1 000   |     1 000 000     |
| O(n\*\*2) |  1  | 10 000 | 1 000 000 | 1 000 000 000 000 |
|   O(n!)   |  1  |  100!  |  1 000!   |    1 000 000!     |

### Сравнение O(n) по времени (если условно 1 операция = 1 секунда)

|           |  1  |     100      |   1 000   | 1 000 0000 |
| :-------: | :-: | :----------: | :-------: | :--------: |
| O(log n)  |  1  |     7 с      |   10 с    |    20 с    |
|   O(n)    |  1  | 1 мин 40 сек |  16 мин   | 11.5 дней  |
| O(n\*\*2) |  1  |   166 мин    | 11.5 дней | 31 709 лет |
|   O(n!)   |  1  |     100!     |  1 000!   | 1 000 000! |

## Данные

Глобально почти во всех языках программирования есть примитивные типы данных и сложные (объекты).

### Примитивы

- числа
- строки
- булев тип
- null
- ...

### Объекты

- в JS массив - частный случай объекта

```js
{
    name: "Something name",
    age: 25,
}

```

Примитивы хранятся по значению в стеке.

```js
const zero = 'value';
# ниже значения просто копируются
const first = 5;
const second = first
```

Объекты, массивы и другие коллекции - ссылочные типы данных.

```js
const user = {
  username: "Pedro",
  password: "123456",
};
```

В стеке `user` - это адрес в памяти в куче (heap)

То есть у объектов хранится только ссылка на адрес в памяти.

В куче (heap) хранится сам объект.

В этом случае при присвоении никакого копирования не происходит, присваивается ссылка, которая будет ссылаться на тот же адрес в куче.

## Массивы

```js
const array = [1, 10, 15, 2, 7, 9];
```

|  Индекс  |  0  |  1  |  2  |  3  |  4  |  5  |
| :------: | :-: | :-: | :-: | :-: | :-: | :-: |
| Значение |  1  | 10  | 15  |  2  |  7  |  9  |

0 - адрес первого элемента

размер массива = количество

размер ячейки в памяти известен

Когда создаётся массив на n элементов, в памяти выделяется непрерывный кусок, где все элементы расположены непрерывно.

При добавлении нового элемента может возникнуть трудность `arr.push(1)`:
место для нового элемента может быть уже занято другими данными.

**Статический массив** - массив под который выделено строго определенное количество памяти (заранее известно количество допустимых ячеек). В такой нельзя добавлять новые элементы, можно только заменять существующие.

Проблему с добавлением одного нового элемента можно решить созданием нового массива на 1 ячейку больше. В новый массив копируются все старые данные, а в конец добавляется 1 новый элемент.

Чтобы оптимизировать этот процесс и на каждое добавление не делать копирование, чаще всего создаётся новый массив с запасом.

Массив, в котором не нужно думать о размере массива м можно спокойно добавлять новые элементы называется **динамическим**. `arr.push(5);`

Динамический массив реализуется как обёртка над статическим, с созданием нового массива, копированием и удалением старого массива из памяти.

### Сложность операций над массивом

|                  Операция                  | Сложность |
| :----------------------------------------: | :-------: |
|             Получение элемента             |   O(1)    |
| Вставка в конец (амортизированная вставка) |   O(1)    |
|              Вставка в конец               |   O(n)    |
|              Вставка в начало              |   O(n)    |
|     Удаление из начала или по индексу      |   O(n)    |
|              Удаление c конца              |   O(1)    |

### Виды массивов в JS

1. Плотный (packed):

`[1,10,15,2,7,9]` - элементы одного типа без пропусков

2. Разреженный (holey):

`[1, 'str', object [], true]` - элементы разного типа

По-сути это хэш-таблица

```
{
    0: 1
    2: 'str'
    ...
}
```

## Бинарный поиск

Есть упорядоченный массив

`[1, 4, 8, 25, 1101, 1400, 2100, 4001]`

Частая задача - найти элемент в коллекции

Линейный поиск - самая простая реализация

Задача: вызывается функция `search(1400)`, задача найти 1400 в массиве.

```js
function search(array, search_element) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === search_element) {
      return true;
    }
  }
  return false;
}

array = [1, 4, 8, 25, 1101, 1400, 2100, 4001];

console.log(search(array, 1400));
```

```python
array = [1, 4, 8, 25, 1101, 1400, 2100, 4001]

def linear_search(array, search_element):
    for i in range(len(array)):
        if array[i] == search_element:
            return True
    return False

print(linear_search(array, 1400))

```

Сложность алгоритма линейного поиска - линейная, потому что перебирается весь объём входных данных.

Бинарный поиск - работаем с упорядоченным массивом.

Суть алгоритма - делим пополам и берём элемент посередине.

### Сравнение бинарного поиска и обычного поиска

|            Обычный поиск O(n)            |      Бинарный поиск O(log n)      |
| :--------------------------------------: | :-------------------------------: |
|       100 элементов - 100 итераций       |    100 элементов - 7 итераций     |
|    1 000 элементов - 1 0000 итераций     |   1 000 элементов - 10 итераций   |
| 1 000 000 элементов - 1 000 000 итераций | 1 000 000 элементов - 20 итераций |

Бинарный поиск сработает только на отсортированном массиве. Пример: словарь или адресная книга.

## Рекурсия

Рекурсивная функция - функция, которая вызывает саму себя. Для того, чтобы рекурсивная функция не вызывалась бесконечно, должны быть 2 условия:

1. базовый случай (условия выхода)
2. рекурсивный случай (вызов себя же с другим аргументом)

Когда вызывается функция, она попадает в стек вызовов (call stack)

```
# call stack

factorial(1)
factorial(2)
factorial(3)
factorial(4)
factorial(5)

```

### Задачи, решаемые с помощью рекурсии

- Обход вложенных структур (деревья и графы)
- Решение задач типа "разделяй и властвуй"
- Алгоритмы поиска
- Обратное построение данных (например, разбор выражений, обработка DOM)

Пример задач типа "разделяй и властвуй" - задачи на быструю сортировку.

Рекурсией не стоит злоупотреблять потому что:

1. Возможно переполнение стека вызовов
2. Циклы работают быстрее
3. Дебаг и анализ усложняется (в сравнении с циклом)

Если задачу можно решить циклом в большинстве случаев её лучше сделать циклом.

## Сортировка

**Сортировка** - процесс упорядочивания элементов массива или списка по определённому критерию.

```
[5, 1, 3, 9 , 11, 25] -> [1, 3, 5, 9, 11, 25]
```

Самые популярные сортировка:

1. Bubble sort (пузырьковая сортировка, O(n\*\*2))
2. Selection sort (сортировка выбором, O(n\*\*2))
3. Quick sort (быстрая сортировка, O(n \* log n))

### Сортировка выбором

1. Ищется минимальный элемент и ставится в начало
2. Далее ищется следующий минимальный элемент, ставится на 2 место (индекс=1) и так далее

Ищем минимальные числа пока не отсортируем весь массив.

### Пузырьковая сортировка

Сложность O(n\*\*2)

Неэффективный алгоритм

Элементы начинают "всплывать"

## Принцип разделяй и властвуй

Принцип "Разделяй и властвуй" состоит из 3 этапов:

1. Разделяй (divide)
2. Властвуй (Conquer)
3. Объединяй (Combine)

## Рассмотренные алгоритмы

|  #  |  Название алгоритма   |            JS             |          Python           |
| :-: | :-------------------: | :-----------------------: | :-----------------------: |
|  1  |    Линейный поиск     | [смотреть код](ex_004.js) | [смотреть код](ex_004.py) |
|  2  |    Бинарный поиск     | [смотреть код](ex_005.js) | [смотреть код](ex_005.py) |
|  3  | Рекурсивный факториал | [смотреть код](ex_006.js) | [смотреть код](ex_006.py) |
|  4  |  Сортировка выбором   | [смотреть код](ex_007.js) | [смотреть код](ex_007.py) |
|  5  | Сортировка пузырьком  | [смотреть код](ex_008.js) | [смотреть код](ex_008.py) |
