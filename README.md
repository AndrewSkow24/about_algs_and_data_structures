# Алгоритмы и структуры данных

## Темы

1. Основы алгоритмов
2. Оценка сложности (big O, временная и пространственная)
3. Работа с данными (стек, куча heap)
4. Как устроены массивы и как хранятся в памяти
5. Поиск (линейный и бинарный)
6. Рекурсия
7. Разделяй и властвуй
8. Сортировка (пузырьком, выбором, быстрая сортировка 2 способа)
9. Связные списки
10. Стек
11. Очередь и дек
12. Графы. Поиск в ширину и глубину. Алгоритмы Дейкстры. Матрица смежности
13. Многомерные массивы
14. Деревья. Бинарное дерево поиска. Дерево N-размерности
15. Хэш-таблицы
16. Комбинаторика. Перестановки, сочетания и размещения
17. Жадные алгоритмы

## Основы алгоритмов

Повторяющиеся действия называются итерациями и выполняются в цикле.
Алгоритм в коде - это последовательность действий.
Алгоритм может быть эффективный или неэффективный.

## Оценка алгоритма

Эффективность алгоритма оценивается

1. По времени (количество операций)
2. По затраченным ресурсам (память)

Под временем не подразумеваются секунды, а подразумевается временная
сложность O(n).

Эффективность алгоритма по памяти называется пространственная
сложность O(n).

В обоих случаях используется нотация big O: O(n)

Нотация O(n) не сообщает нам точное количество операций или
точный объём данных, а показывает как растёт функция с ростом входных данных или ростом
количества операций.

### Примеры алгоритмической сложности

1. `O(1)` - константная
2. `O(log n)` - логарифмическая
3. `O(n)` - линейная
4. `O(n**2)` - квадратичная
5. `O(n**3)` - кубическая
6. `O(n!)` - факториальная

Логарифмическая сложность характерна для алогритмов, где
объём исходных данных делится на 2.

Пример линейной сложности - обработка массива в цикле.

Квадратичная сложность: цикл в цикле

Кубическая сложность: цикл в цикле в цикле

Логарифмическая сложность: данные делятся на 2 части, и дальнейшая работа только с оставшимися
частями.

```
[1,2,3,4,5,6,7,8,9,10]

Делится на

[1,2,3,4,5]

и

[6,7,8,9,10]
```

Квадратичная сложность - 2 вложенных цикла

```js
const data = [1, 2, 3, 4, 5];

for (let i = 0; i < data.length; i++) {
  for (let j = 0; j < data.length; j++) {
    //
  }
}
```

Если два исходных массива с разным количеством элементов сложность будет `O(k*m)`

```js
const data = [1, 2, 3, 4, 5];
const data2 = [1, 2, 3];

for (let i = 0; i < length; i++) {
  for (let j = 0; j < length; j++) {
    //
  }
}
```

Функция с факториальной временной сложностью `O(n!)` выполняет работа, которая увеличивается факториально с ростом входных данных. Пример: генерация всех перестановок массива.

Константы при оценки сложности алгоритма не учитываются, они отбрасываются, потому что на рост функции они никак не влияют.

Сложность не призвана отобразить точное количество операций.

Она показывает как растёт функция с ростом входных данных.

### Сравнение O(n) и количества операций

|           |  1  |  100   |   1 000   |    1 000 0000     |
| :-------: | :-: | :----: | :-------: | :---------------: |
| O(log n)  |  1  |   7    |    10     |        20         |
|   O(n)    |  1  |  100   |   1 000   |     1 000 000     |
| O(n\*\*2) |  1  | 10 000 | 1 000 000 | 1 000 000 000 000 |
|   O(n!)   |  1  |  100!  |  1 000!   |    1 000 000!     |

### Сравнение O(n) по времени (если условно 1 операция = 1 секунда)

|           |  1  |     100      |   1 000   | 1 000 0000 |
| :-------: | :-: | :----------: | :-------: | :--------: |
| O(log n)  |  1  |     7 с      |   10 с    |    20 с    |
|   O(n)    |  1  | 1 мин 40 сек |  16 мин   | 11.5 дней  |
| O(n\*\*2) |  1  |   166 мин    | 11.5 дней | 31 709 лет |
|   O(n!)   |  1  |     100!     |  1 000!   | 1 000 000! |

## Данные

Глобально почти во всех языках программирования есть примитивные типы данных и сложные (объекты).

### Примитивы

- числа
- строки
- булев тип
- null
- ...

### Объекты

- в JS массив - частный случай объекта

```js
{
    name: "Something name",
    age: 25,
}

```

Примитивы хранятся по значению в стеке.

```js
const zero = 'value';
# ниже значения просто копируются
const first = 5;
const second = first
```

Объекты, массивы и другие коллекции - ссылочные типы данных.

```js
const user = {
  username: "Pedro",
  password: "123456",
};
```

В стеке `user` - это адрес в памяти в куче (heap)

То есть у объектов хранится только ссылка на адрес в памяти.

В куче (heap) хранится сам объект.

В этом случае при присвоении никакого копирования не происходит, присваивается ссылка, которая будет ссылаться на тот же адрес в куче.

## Массивы

```js
const array = [1, 10, 15, 2, 7, 9];
```

|  Индекс  |  0  |  1  |  2  |  3  |  4  |  5  |
| :------: | :-: | :-: | :-: | :-: | :-: | :-: |
| Значение |  1  | 10  | 15  |  2  |  7  |  9  |

0 - адрес первого элемента

размер массива = количество

размер ячейки в памяти известен

Когда создаётся массив на n элементов, в памяти выделяется непрерывный кусок, где все элементы расположены непрерывно.

При добавлении нового элемента может возникнуть трудность `arr.push(1)`:
место для нового элемента может быть уже занято другими данными.

**Статический массив** - массив под который выделено строго определенное количество памяти (заранее известно количество допустимых ячеек). В такой нельзя добавлять новые элементы, можно только заменять существующие.

Проблему с добавлением одного нового элемента можно решить созданием нового массива на 1 ячейку больше. В новый массив копируются все старые данные, а в конец добавляется 1 новый элемент.

Чтобы оптимизировать этот процесс и на каждое добавление не делать копирование, чаще всего создаётся новый массив с запасом.

Массив, в котором не нужно думать о размере массива м можно спокойно добавлять новые элементы называется **динамическим**. `arr.push(5);`

Динамический массив реализуется как обёртка над статическим, с созданием нового массива, копированием и удалением старого массива из памяти.

### Сложность операций над массивом

|                  Операция                  | Сложность |
| :----------------------------------------: | :-------: |
|             Получение элемента             |   O(1)    |
| Вставка в конец (амортизированная вставка) |   O(1)    |
|              Вставка в конец               |   O(n)    |
|              Вставка в начало              |   O(n)    |
|     Удаление из начала или по индексу      |   O(n)    |
|              Удаление c конца              |   O(1)    |

### Виды массивов в JS

1. Плотный (packed) :

`[1,10,15,2,7,9]` - элементы одного
