# Алгоритмы и структуры данных

## Темы

1. Основы алгоритмов
2. Оценка сложности (big O, временная и пространственная)
3. Работа с данными (стек, куча heap)
4. Как устроены массивы и как хранятся в памяти
5. Поиск (линейный и бинарный)
6. Рекурсия
7. Разделяй и властвуй
8. Сортировка (пузырьком, выбором, быстрая сортировка 2 способа)
9. Связные списки
10. Стек
11. Очередь и дек
12. Графы. Поиск в ширину и глубину. Алгоритмы Дейкстры. Матрица смежности
13. Многомерные массивы
14. Деревья. Бинарное дерево поиска. Дерево N-размерности
15. Хэш-таблицы
16. Комбинаторика. Перестановки, сочетания и размещения
17. Жадные алгоритмы

## Основы алгоритмов

Повторяющиеся действия называются итерациями и выполняются в цикле.
Алгоритм в коде - это последовательность действий.
Алгоритм может быть эффективный или неэффективный.

## Оценка алгоритма

Эффективность алгоритма оценивается

1. По времени (количество операций)
2. По затраченным ресурсам (память)

Под временем не подразумеваются секунды, а подразумевается временная
сложность O(n).

Эффективность алгоритма по памяти называется пространственная
сложность O(n).

В обоих случаях используется нотация big O: O(n)

Нотация O(n) не сообщает нам точное количество операций или
точный объём данных, а показывает как растёт функция с ростом входных данных или ростом
количества операций.

### Примеры алгоритмической сложности

1. `O(1)` - константная
2. `O(log n)` - логарифмическая
3. `O(n)` - линейная
4. `O(n**2)` - квадратичная
5. `O(n**3)` - кубическая
6. `O(n!)` - факториальная

Логарифмическая сложность характерна для алогритмов, где
объём исходных данных делится на 2.

Пример линейной сложности - обработка массива в цикле.

Квадратичная сложность: цикл в цикле

Кубическая сложность: цикл в цикле в цикле

Логарифмическая сложность: данные делятся на 2 части, и дальнейшая работа только с оставшимися
частями.

```
[1,2,3,4,5,6,7,8,9,10]

Делится на

[1,2,3,4,5]

и

[6,7,8,9,10]
```

Квадратичная сложность - 2 вложенных цикла

```js
const data = [1, 2, 3, 4, 5];

for (let i = 0; i < data.length; i++) {
  for (let j = 0; j < data.length; j++) {
    //
  }
}
```

Если два исходных массива с разным количеством элементов сложность будет `O(k*m)`

```js
const data = [1, 2, 3, 4, 5];
const data2 = [1, 2, 3];

for (let i = 0; i < length; i++) {
  for (let j = 0; j < length; j++) {
    //
  }
}
```

Функция с факториальной временной сложностью `O(n!)` выполняет работа, которая увеличивается факториально с ростом входных данных. Пример: генерация всех перестановок массива.

Константы при оценки сложности алгоритма не учитываются, они отбрасываются, потому что на рост функции они никак не влияют.

Сложность не призвана отобразить точное количество операций.

Она показывает как растёт функция с ростом входных данных.
